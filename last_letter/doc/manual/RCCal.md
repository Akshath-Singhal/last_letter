## Input device configuration and calibration

This section provides instructions on how to configure your input device for the aircraft simulated in `last_letter`. This is required if you intend to control them manually. If you expect the aircraft control inputs to be generated by a controller (such as the arduipilot SITL), you don't have to perform the following steps.

### The `ROS joy` package
`last_letter` uses the [`joy`](http://wiki.ros.org/joy) ROS package to interface with input devices, which include many joysticks and gamepads. If your device can be read by `joy`, you can use it to control your aircraft in `last_letter`. However, configuration is required.

By default, `joy` expects to find the input device as `/dev/input/js0`. If your device is not mounted there, you should refer to this [tutorial](http://wiki.ros.org/joy/Tutorials/ConfiguringALinuxJoystick).
If your device is in another `jsX` port, then you can change accordingly this line
```xml
<param name="dev" value="/dev/input/js0" />
```
in the `last_letter/launch/simulation.launch` file.

### Configuration procedure
By following the configuration procedure, you will edit the `/last_letter/data/parameters/HID.yaml` file according to your input device. Open this file in your favourite text editor now. Comment out all lines and prepare a new device configuration by copying the provided template and un-commenting it.

Next, raise a ROS core, by typing in a terminal:
```bash
roscore
```
In a new terminal, type
```bash
rosrun joy joy_node
```
The output should be something like
```bash
[ INFO] [1431444728.249336803]: Opened joystick: /dev/input/js0. deadzone_: 0.050000.
```
Open yet another terminal and type
```bash
rostopic echo /joy
```
Move a control stick in your device to publish some messages. They should look like
```bash
header:
  seq: 409
  stamp:
    secs: 1431444879
    nsecs: 354395104
  frame_id: ''
axes: [0.0, 0.0, 0.6527636051177979, 0.0, -0.0]
buttons: [0, 0, 0]
```

Notice that the `/joy` topic has an `axes` and a `buttons` field, which will have variable size, depending on your device. These fields are **zero-based** arrays.

In the following section, you will re-map your device axes to match the following order of the virtual PWM input, which `last_letter` passes to the physics model:

Move the stick that corresponds to the roll axis at full deflection, in the direction which rolls your aircraft to the right. Take a note of **the (zero-based!) index** of the *axes* array element that changed and its **value**. This value should normally be between -1 and 1. Copy the **index** at the `/HID/axes[0]` array element and the **value** at the `/HID/throws[0]` array element.

Do the same for the elevator axis, by giving full deflection in the direction that pitches the aircaft upwards, and filling the `/HID/axes[1]` and `/HID/throws[1]` entries.

Do the same for the throttle axis, by opening the throttle at its maximum throw and filling the `/HID/axes[2]` and `/HID/throws[2]` entries.

Do the same for the rudder axis, by giving full deflection towards the direction that yaws your aircraft to the right. Fill the entries `/HID/axes[3]` and `/HID/throws[3]`.

Leave the `/HID/buttons` array and the rest of the `/HID/axes` and `/HID/throws` elements intact. They do not need to change for basic RC flight.

The input device configuration procedure is complete.

### Supported devices
So far the following devices have been successfuly tested with `last_letter`:
* Microsoft SideWinder 2 joystick
![MS SideWinder Joy](figures/microsoftjoy1.jpg){ width: 600px; }
* E-Sky 0905A USB Transmitter
![E-Sky 0905A](figures/e-sky_0905a.jpg){ width: 600px; }
* Digital Element GM-400
![DE GM-400](figures/gm-400.jpg){ width: 600px; }

Configuration parameters for those devices can already be found on the `HID.yaml` file. In order to use them, leave only the corresponding lines uncommented.


[back to table of contents](../../../README.md)